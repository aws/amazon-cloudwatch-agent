#!/bin/sh

# Copyright 2017 Amazon.com, Inc. and its affiliates. All Rights Reserved.
#
# Licensed under the Amazon Software License (the "License").
# You may not use this file except in compliance with the License.
# A copy of the License is located at
#
#   http://aws.amazon.com/asl/
#
# or in the "license" file accompanying this file. This file is distributed
# on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
# express or implied. See the License for the specific language governing
# permissions and limitations under the License.

set -e
set -u

readonly AGENTDIR="/opt/aws/amazon-cloudwatch-agent"
readonly CMDDIR="${AGENTDIR}/bin"
readonly CONFDIR="${AGENTDIR}/etc"
readonly LOGDIR="${AGENTDIR}/logs"
readonly RESTART_FILE="${CONFDIR}/restart"
readonly VERSION_FILE="${CMDDIR}/CWAGENT_VERSION"
readonly AGENT_LAUNCHD_NAME="com.amazon.cloudwatch.agent"
readonly AGENT_LAUNCHD_CONFIG="/Library/LaunchDaemons/${AGENT_LAUNCHD_NAME}.plist"

readonly TOML="${CONFDIR}/amazon-cloudwatch-agent.toml"
readonly JSON="${CONFDIR}/amazon-cloudwatch-agent.json"
readonly JSON_DIR="${CONFDIR}/amazon-cloudwatch-agent.d"
readonly CV_LOG_FILE="${AGENTDIR}/logs/configuration-validation.log"
readonly COMMON_CONIG="${CONFDIR}/common-config.toml"

readonly ALL_CONFIG='all'

UsageString="


        usage: amazon-cloudwatch-agent-ctl -a stop|start|status|fetch-config|append-config|remove-config [-m ec2|onPremise|auto] [-c default|ssm:<parameter-store-name>|file:<file-path>] [-s] [-v]

        e.g.
        1. apply a SSM parameter store config on EC2 instance and restart the agent afterwards:
            amazon-cloudwatch-agent-ctl -a fetch-config -m ec2 -c ssm:AmazonCloudWatch-Config.json -s
        2. append a local json config file on onPremise host and restart the agent afterwards:
            amazon-cloudwatch-agent-ctl -a append-config -m onPremise -c file:/tmp/config.json -s
        3. query agent status:
            amazon-cloudwatch-agent-ctl -a status

        -a/--action: action
            stop:                                   stop the agent process.
            start:                                  start the agent process.
            status:                                 get the status of the agent process.
            fetch-config:                           use this json config as the agent's only configuration.
            append-config:                          append json config with the existing json configs if any.
            remove-config:                          remove json config based on the location (ssm parameter store name, file name)

        -m/--mode: mode
            ec2:                                    indicate this is on ec2 host.
            onPremise:                              indicate this is on onPremise host.
            auto:                                   use ec2 metadata to determine the environment, may not be accurate if ec2 metadata is not available for some reason on EC2.

        -c: configuration
            default:                                default configuration for quick trial.
            ssm:<parameter-store-name>:             ssm parameter store name
            file:<file-path>:                       file path on the host
            all:                                    all existing configs. Only apply to remove-config action.

        -s/--restart: optionally restart after configuring the agent configuration
            this parameter is used for 'fetch-config', 'append-config', 'remove-config' action only.

        --strict: Return exit code 99 if validating agent's json config fails.

"

cwa_start() {
     mode="${1:-}"

     if [ "$(cwa_runstatus)" = 'running' ]; then
          return 0
     fi

     if [ ! -f "${TOML}" ]; then
          echo "amazon-cloudwatch-agent is not configured. Applying default configuration before starting it."
          cwa_config 'default' 'false' 'false' "${mode}" 'default'
     fi

     launchctl load $AGENT_LAUNCHD_CONFIG
}

cwa_stop() {
     if [ "$(cwa_runstatus)" = 'stopped' ]; then
          return 0
     fi

     launchctl unload $AGENT_LAUNCHD_CONFIG
}

# support for restart during upgrade via SSM packages
cwa_prep_restart() {
     if [ "$(cwa_runstatus)" = 'running' ]; then
          touch "$RESTART_FILE"
     fi
}

# support for restart during upgrade via SSM packages
cwa_cond_restart() {
     if [ -f "${RESTART_FILE}" ]; then
          cwa_start
          rm -f "${RESTART_FILE}"
     fi
}

cwa_preun() {
     cwa_stop
}

cwa_status() {
     cwa_config_status='configured'
     if [ ! -f "${TOML}" ]; then
          cwa_config_status='not configured'
     fi

     starttime_fmt=''
     local pid=$(cwa_pid)
     if [[ $pid =~ ^[\-0-9]+$ ]] && ((pid > 0)); then
          starttime="$(TZ=UTC LC_ALL=C ps -o lstart= "${pid}")"
          starttime_fmt="$(TZ=UTC date -jf "%a %b %d %T %Y " "${starttime}" +%FT%T%z)"
     else
          echo ${pid}
     fi

     version="$(cat ${VERSION_FILE})"

     echo "{"
     echo "  \"status\": \"$(cwa_runstatus)\","
     echo "  \"starttime\": \"${starttime_fmt}\","
     echo "  \"configstatus\": \"${cwa_config_status}\","
     echo "  \"version\": \"${version}\""
     echo "}"
}

cwa_runstatus() {
     running=false
     set +e
     local pid=$(cwa_pid)
     if [[ "$pid" =~ ^[0-9]+$ ]] && ((pid > 0)); then
          running='true'
     elif [[ "$pid" == "-" ]]; then
          running='true'
     fi
     set -e

     if [ "${running}" = 'true' ]; then
          echo "running"
     else
          echo "stopped"
     fi
}

cwa_pid() {
     echo "$({ sudo launchctl list | grep ${AGENT_LAUNCHD_NAME} | awk '{print $1}'; } 2>/dev/null)"
}

cwa_config() {
     config_location="${1:-}"
     restart="${2:-}"
     mode="${3:-}"
     multi_config="${4:-}"
     strict_validation="${5:-}"

     mkdir -p "${CONFDIR}"

     param_mode="ec2"
     case "${mode}" in
     ec2)
          param_mode="ec2"
          ;;
     onPremise)
          param_mode="onPrem"
          ;;
     auto)
          param_mode="auto"
          ;;
     *)
          echo "Invalid mode: ${mode}" >&2
          exit 1
          ;;
     esac

     if [ "${config_location}" = "${ALL_CONFIG}" ] && [ "${multi_config}" != 'remove' ]; then
          echo "ignore cwa configuration \"${ALL_CONFIG}\" as it is only supported by action \"remove-config\""
          return
     fi

     if [ "${config_location}" = "${ALL_CONFIG}" ]; then
          rm -rf "${JSON_DIR}"/*
     else
          runDownloaderCommand="${CMDDIR}/config-downloader --output-dir ${JSON_DIR} --download-source ${config_location} --mode ${param_mode} --config ${COMMON_CONIG} --multi-config ${multi_config}"
          echo ${runDownloaderCommand}
          ${runDownloaderCommand}
     fi

     if [ ! "$(ls ${JSON_DIR})" ]; then
          echo "all amazon-cloudwatch-agent configurations have been removed"
          rm -f "${TOML}"
     else
          runTranslatorCommand="${CMDDIR}/config-translator --input ${JSON} --input-dir ${JSON_DIR} --output ${TOML} --mode ${param_mode} --config ${COMMON_CONIG} --multi-config ${multi_config} --strict-validation=${strict_validation}"
          echo ${runTranslatorCommand}
          ${runTranslatorCommand}

          runAgentSchemaTestCommand="${CMDDIR}/amazon-cloudwatch-agent -schematest -config ${TOML}"
          echo ${runAgentSchemaTestCommand}
          # We will redirect the verbose error message out
          if ! ${runAgentSchemaTestCommand} >${CV_LOG_FILE} 2>&1; then
               echo "Configuration validation second phase failed"
               echo "======== Error Log ========"
               cat ${CV_LOG_FILE}
               exit 1
          fi
          echo "Configuration validation second phase succeeded"
          echo "Configuration validation succeeded"

          chmod ug+rw "${TOML}"

          # for translator:
          #       default:    only process .tmp files
          #       append:     process both existing files and .tmp files
          #       remove:     only process existing files
          # At this point, all json configs have been validated
          # multi_config:
          #       default:    delete non .tmp file, rename .tmp file
          #       append:     rename .tmp file
          #       remove:     no-op
          if [ "${multi_config}" = 'default' ]; then
               rm -f "${JSON}"
               for file in "${JSON_DIR}"/*; do
                    base="${JSON_DIR}/$(basename "${file}" .tmp)"
                    if [ "${file}" = "${base}" ]; then
                         rm -f "${file}"
                    else
                         mv -f "${file}" "${base}"
                    fi
               done
          elif [ "${multi_config}" = 'append' ]; then
               for file in "${JSON_DIR}"/*.tmp; do
                    mv -f "${file}" "${JSON_DIR}/$(basename "${file}" .tmp)"
               done
          fi

     fi

     if [ "${restart}" = 'true' ]; then
          cwa_stop
          cwa_start "${param_mode}"
     fi
}

getopts_long() {
    # Function utilizies getopts, which "upgrades" the built-in getopts with support for GNU-style long options
    # Documentation: https://github.com/UrsaDK/getopts_long
    # Example for using getopts: https://github.com/UrsaDK/getopts_long#example-script
    # There are two ways of using it without external dependencies:
    # - Use docker (up-to-date with github; however, do we want every customer to install docker before using cwagent when they only use the binaries and artifacts')
    # - Create a getopts_long function(not up-to-date with github; however, do not need to install docker)

    : "${1:?Missing required parameter -- long optspec}"
    : "${2:?Missing required parameter -- variable name}"

    local optspec_short="${1%% *}-:"
    local optspec_long="${1#* }"
    local optvar="${2}"

    shift 2

    if [[ "${#}" == 0 ]]; then
        local args=()
        while [[ ${#BASH_ARGV[@]} -gt ${#args[@]} ]]; do
            local index=$(( ${#BASH_ARGV[@]} - ${#args[@]} - 1 ))
            args[${#args[@]}]="${BASH_ARGV[${index}]}"
        done
        set -- "${args[@]}"
    fi

    builtin getopts "${optspec_short}" "${optvar}" "${@}" || return 1
    [[ "${!optvar}" == '-' ]] || return 0

    printf -v "${optvar}" "%s" "${OPTARG%%=*}"

    if [[ "${optspec_long}" =~ (^|[[:space:]])${!optvar}:([[:space:]]|$) ]]; then
        OPTARG="${OPTARG#${!optvar}}"
        OPTARG="${OPTARG#=}"

        # Missing argument
        if [[ -z "${OPTARG}" ]]; then
            OPTARG="${!OPTIND}" && OPTIND=$(( OPTIND + 1 ))
            [[ -z "${OPTARG}" ]] || return 0

            if [[ "${optspec_short:0:1}" == ':' ]]; then
                OPTARG="${!optvar}" && printf -v "${optvar}" ':'
            else
                [[ "${OPTERR}" == 0 ]] || \
                    echo "${0}: option requires an argument -- ${!optvar}" >&2
                unset OPTARG && printf -v "${optvar}" '?'
            fi
        fi
    elif [[ "${optspec_long}" =~ (^|[[:space:]])${!optvar}([[:space:]]|$) ]]; then
        unset OPTARG
    else
        # Invalid option
        if [[ "${optspec_short:0:1}" == ':' ]]; then
            OPTARG="${!optvar}"
        else
            [[ "${OPTERR}" == 0 ]] || echo "${0}: illegal option -- ${!optvar}" >&2
            unset OPTARG
        fi
        printf -v "${optvar}" '?'
    fi
}

main() {
     action=''
     config_location='default'
     restart='false'
     strict_validation='false'
     mode='auto'

     OPTIND=1
     while getopts_long ":hsa:r:c:m: help restart strict action: mode:" opt; do
          case "${opt}" in
          'h'|'help')
               echo "${UsageString}"
               exit 0
               ;;
          's'|'restart') restart='true' ;;
          'a'|'action') action="${OPTARG}" ;;
          c) config_location="${OPTARG}" ;;
          'm'|'mode') mode="${OPTARG}" ;;
          'strict') strict_validation='true';;
          \?)
               echo "Invalid option: -${OPTARG} ${UsageString}" >&2
               ;;
          :)
               echo "Option -${OPTARG} requires an argument ${UsageString}" >&2
               exit 1
               ;;
          esac
     done
     shift "$((${OPTIND} - 1))"

     case "${mode}" in
     ec2) ;;

     onPremise) ;;

     auto) ;;

     *)
          echo "Invalid mode: ${mode} ${UsageString}" >&2
          exit 1
          ;;
     esac

     current_user=$(id -u -n)
     if [ "${action}" != 'status' -a "${current_user}" != 'root' ]; then
          echo "Please use root to run this script"
          exit 1
     fi

     case "${action}" in
     stop) cwa_stop ;;
     start) cwa_start "${mode}" ;;
     fetch-config) cwa_config "${config_location}" "${restart}" "${mode}" 'default' "${strict_validation}";;
     append-config) cwa_config "${config_location}" "${restart}" "${mode}" 'append' "${strict_validation}";;
     remove-config) cwa_config "${config_location}" "${restart}" "${mode}" 'remove' "${strict_validation}";;
     status) cwa_status ;;
          # helpers for ssm package scripts to workaround fact that it can't determine if invocation is due to
          # upgrade or install
     prep-restart) cwa_prep_restart ;;
     cond-restart) cwa_cond_restart ;;
     preun) cwa_preun ;;
     *)
          echo "Invalid action: ${action} ${UsageString}" >&2
          exit 1
          ;;
     esac
}

main "$@"
